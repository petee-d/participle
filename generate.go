package participle

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/alecthomas/participle/v2/lexer"
)

const (
	generatedInitialSliceCapacity = 2
)

// TODO: don't create checkpoints for single-token nodes

type genErrorType int8

const (
	genNoError = iota
	genTokenError
	genParseError
)

type GeneratedParserContext struct {
	Lex       *lexer.PeekingLexer
	Lookahead int

	hasErr         bool
	errWasOptional bool
	errType        genErrorType
	errCursor      int
	errRawCursor   lexer.RawCursor
	errInfo        string
	err            error
}

func (e *GeneratedParserContext) SetNoError(wasOptional bool) {
	e.hasErr = false
	e.errWasOptional = wasOptional
}

func (e *GeneratedParserContext) SetTokenError(expect string) {
	e.setError(genTokenError, expect)
}

func (e *GeneratedParserContext) SetParseError(msg string) {
	e.setError(genParseError, msg)
}

func (e *GeneratedParserContext) AddTokenErrorExpected(expect string) {
	// TODO ` && e.info == ""` for consistency with old behavior?
	if e.hasErr && e.errType == genTokenError && e.errCursor == e.Lex.Cursor() {
		e.errInfo = expect
	}
}

func (e *GeneratedParserContext) setError(typ genErrorType, info string) {
	if !e.errWasOptional && e.errType != genNoError && e.errCursor > e.Lex.Cursor() {
		e.hasErr = true
		return
	}
	e.hasErr = true
	e.errWasOptional = false
	e.errType = typ
	e.errCursor = e.Lex.Cursor()
	e.errRawCursor = e.Lex.RawCursor()
	e.errInfo = info
}

func (e *GeneratedParserContext) HasErr() bool {
	return e.hasErr
}

func (e *GeneratedParserContext) RestoreOptionalError() {
	if e.errWasOptional {
		e.hasErr = true
	}
	e.errWasOptional = false
}

func (e *GeneratedParserContext) AboveLookahead(checkpoint lexer.Checkpoint) bool {
	return e.errCursor-checkpoint.Cursor() > e.Lookahead
}

func (e *GeneratedParserContext) AsError() error {
	if !e.hasErr {
		return nil
	}
	switch e.errType {
	case genNoError:
		return nil
	case genTokenError:
		return &UnexpectedTokenError{Unexpected: e.Lex.At(e.errRawCursor), Expect: e.errInfo}
	case genParseError:
		return NewError(e.Lex.At(e.errRawCursor).Pos, e.errInfo)
	default:
		panic(fmt.Errorf("unknown generated error type: %v", e.errType))
	}
}

type codeGenerator struct {
	parser           *parserOptions
	symbols          map[string]lexer.TokenType
	caseInsensitive  map[lexer.TokenType]bool
	packagePrefix    string
	lookahead        int
	printAllocations bool
	parserName       string

	out            bytes.Buffer
	lines          int
	indent         int
	structs        map[string]generatedStruct
	missingStructs []string
}

type generatedStruct struct {
	node   *strct
	usages int
}

func GenerateCode[G any](parser *Parser[G], dstPackage string, dstPackageExternal bool) []byte {
	rootNode := parser.typeNodes[parser.rootType].(*strct)
	rootType := rootNode.typ.Name()
	normalizedName := rootNode.normalizedName()
	gen := codeGenerator{
		parser:           &parser.parserOptions,
		symbols:          parser.lex.Symbols(),
		caseInsensitive:  parser.findCaseInsensitiveTokens(),
		packagePrefix:    "",
		lookahead:        parser.useLookahead,
		printAllocations: false,
		parserName:       fmt.Sprintf("generated%sParser", normalizedName),

		structs: map[string]generatedStruct{},
	}
	if dstPackageExternal {
		gen.packagePrefix = "source."
	}
	gen.queueGeneratingStruct(rootNode)

	gen.statement(`// Code generated by participle parser generator. DO NOT EDIT.`)
	gen.statement(`// source: ` + rootNode.typ.PkgPath() + `.` + rootType)
	gen.statement(``)
	gen.statement(`package ` + dstPackage)
	gen.statement(``)
	gen.statement(`import (`)
	gen.statementIndent(`"strconv"`)
	gen.statement(``)
	gen.statementIndent(`"github.com/alecthomas/participle/v2"`)
	gen.statementIndent(`"github.com/alecthomas/participle/v2/lexer"`)
	if dstPackageExternal {
		gen.statement(``)
		gen.statementIndent(`source "github.com/alecthomas/participle/v2"`)
	}
	gen.statement(`)`)
	gen.statement(``)
	gen.statement(fmt.Sprintf(`func Parse%s(lex *lexer.PeekingLexer, out *%s%s, allowTrailing bool) error {`,
		normalizedName, gen.packagePrefix, rootType))
	gen.indent++
	gen.statement(`*out = ` + gen.packagePrefix + rootType + `{}`)
	gen.statement(fmt.Sprintf(`var p %s`, gen.parserName))
	gen.statement(`p.Lex = lex`)
	gen.statement(fmt.Sprintf(`p.Lookahead = %d`, gen.lookahead))
	gen.statement(fmt.Sprintf(`p.parse%s(out)`, normalizedName))
	gen.statement(`if !p.HasErr() && !(lex.Current().EOF() || allowTrailing) {`) // TODO: DeepestError!
	gen.statementIndent(`p.RestoreOptionalError()`)
	gen.statementIndent(`p.SetTokenError("")`)
	gen.statement(`}`)
	gen.statement(`return p.AsError()`)
	gen.indent--
	gen.statement(`}`)
	gen.statement(``)
	gen.statement(`type ` + gen.parserName + ` struct {`)
	gen.statementIndent(`participle.GeneratedParserContext`)
	gen.statement(`}`)

	for len(gen.missingStructs) > 0 {
		item := gen.structs[gen.missingStructs[0]]
		gen.missingStructs = gen.missingStructs[1:]
		normalizedName := item.node.normalizedName()
		state := generatorState{
			target: generatedVariable{
				name:         `out`,
				rValuePrefix: `*`,
				typ:          item.node.typ,
			},
			errorLabel: gen.newLabel(`strct`+normalizedName, `Error`),
		}

		gen.statement(``)
		gen.statement(fmt.Sprintf(`func (p *%s) parse%s(out *%s%s) {`,
			gen.parserName, normalizedName, gen.packagePrefix, item.node.typ.Name()))
		gen.indent++
		gen.statement(`current := p.Lex.Current()`)
		gen.statement(`p.SetNoError(false)`)
		item.node.generateBody(state, &gen)
		gen.writeLabel(state.errorLabel)
		gen.indent--
		gen.statement(`}`)
	}

	return gen.out.Bytes()
}

func (g *codeGenerator) queueGeneratingStruct(node *strct) {
	name := node.typ.String()
	if item, ok := g.structs[name]; !ok {
		g.missingStructs = append(g.missingStructs, name)
		g.structs[name] = generatedStruct{node: node, usages: 1}
	} else {
		item.usages++
		g.structs[name] = item
	}
}

func (g *codeGenerator) shouldUseDirectCaptureForType(targetType reflect.Type) bool {
	switch kind := targetType.Kind(); kind {
	case reflect.String, reflect.Bool, reflect.Slice:
		return true
	default:
		return false
	}
}

func (g *codeGenerator) captureTokens(state generatorState) {
	g.captureTokenPrimitive(state, state.capture.field.Type, state.targetRef())
}

func (g *codeGenerator) captureTokenPrimitive(state generatorState, targetType reflect.Type, targetRef string) {
	srcRef := state.capture.sourceRef()
	switch kind := targetType.Kind(); kind {
	case reflect.String:
		// TODO: Not great if a pointer? Also won't work if capturing multiple tokens
		// TODO: This could be known statically if captures weren't split...
		// Using assignment instead of concatenation is faster for empty strings, even with the extra check
		g.statement(`if ` + targetRef + ` == "" {`)
		g.statementIndent(targetRef + ` = ` + srcRef)
		g.statement(`} else {`)
		g.reportAllocation("concatenating strings for "+targetRef, ``, 1)
		g.statementIndent(targetRef + ` += ` + srcRef)
		g.statement(`}`)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		convert := fmt.Sprintf(`strconv.ParseInt(%s, 0, %d)`, srcRef, sizeOfKind(kind))
		g.captureTokenNumber(state, kind, reflect.Int64, targetRef, convert)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		convert := fmt.Sprintf(`strconv.ParseUint(%s, 0, %d)`, srcRef, sizeOfKind(kind))
		g.captureTokenNumber(state, kind, reflect.Uint64, targetRef, convert)
	case reflect.Float32, reflect.Float64:
		convert := fmt.Sprintf(`strconv.ParseFloat(%s, %d)`, srcRef, sizeOfKind(kind))
		g.captureTokenNumber(state, kind, reflect.Float64, targetRef, convert)
	case reflect.Bool:
		if !state.capture.direct {
			g.statement(`var _ = ` + srcRef) // Prevent an error due to the capture buffer being unused
		}
		g.statement(targetRef + ` = true`)
	case reflect.Ptr:
		g.statement(`{`)
		g.indent++
		g.statement(`var ptrValue ` + targetType.Elem().String())
		g.statement(`if ` + targetRef + ` != nil {`)
		g.statementIndent(`ptrValue = *` + targetRef)
		g.statement(`}`)
		g.captureTokenPrimitive(state, targetType.Elem(), `ptrValue`)
		g.reportAllocation("capturing pointer "+targetRef, ``, 0)
		g.statement(targetRef + ` = &ptrValue`)
		g.indent--
		g.statement(`}`)
	case reflect.Slice:
		g.statement(`{`)
		g.indent++
		// Appending to a nil slice will allocate capacity 1, likely creating unnecessary allocations
		g.statement(`if ` + targetRef + ` == nil {`)
		g.reportAllocation("making slice "+targetRef, ``, 1)
		g.statementIndent(fmt.Sprintf(`%s = make([]%s, 0, %d)`,
			targetRef, targetType.Elem().String(), generatedInitialSliceCapacity))
		g.statement(`}`)
		g.statement(`var sliceItem ` + targetType.Elem().String())
		g.captureTokenPrimitive(state, targetType.Elem(), `sliceItem`)
		g.reportAllocation("appending to slice "+targetRef, `len(`+targetRef+`) == cap(`+targetRef+`)`, 0)
		g.statement(fmt.Sprintf(`%s = append(%s, sliceItem)`, targetRef, targetRef))
		g.indent--
		g.statement(`}`)
	default:
		panic(fmt.Errorf("generator encountered unsupported struct field type: %v", targetType))
	}
}

func (g *codeGenerator) captureTokenNumber(state generatorState, kind, produces reflect.Kind, targetRef, convert string) {
	g.statement(`if numValue, err := ` + convert + `; err != nil {`)
	g.statementIndent(`p.SetParseError(err.Error())`) // TODO store err in it instead!
	g.gotoLabelIndent(state.errorLabel, 1)
	g.statement(`} else {`)
	if kind == produces {
		g.statementIndent(targetRef + ` = numValue`)
	} else {
		g.statementIndent(fmt.Sprintf(`%s = %s(numValue)`, targetRef, kind.String()))
	}
	g.statement(`}`)
}

func (g *codeGenerator) captureStruct(state generatorState, value generatedVariable, usages int) {
	targetRef := state.targetRef()
	switch state.capture.field.Type.Kind() {
	case reflect.Struct:
		g.statement(targetRef + ` = ` + value.name)
	case reflect.Ptr:
		// Without this trick, the variable would always be allocated on heap, causing allocations even when not needed
		// Most times, the overhead of copying the value from stack to heap will be lower than the needless allocations TODO!!@@@@
		if usages > 1 {
			g.reportAllocation("capturing struct pointer "+targetRef+" = "+value.name, ``, 0)
			g.statement(targetRef + ` = &` + value.name)
		} else {
			g.statement(`{`)
			g.reportAllocation("capturing struct pointer "+targetRef+" = "+value.name, ``, 1)
			g.statementIndent(value.name + `Heap := ` + value.name)
			g.statementIndent(targetRef + ` = &` + value.name + `Heap`)
			g.statement(`}`)
		}
	case reflect.Slice:
		// Appending to a nil slice will allocate capacity 1, likely creating unnecessary allocations
		g.statement(`if ` + targetRef + ` == nil {`)
		g.reportAllocation("making struct slice "+targetRef, ``, 1)
		g.statementIndent(fmt.Sprintf(`%s = make([]%s%s, 1, %d)`,
			targetRef, g.packagePrefix, value.typ.Name(), generatedInitialSliceCapacity))
		g.statementIndent(targetRef + `[0] = ` + value.name)
		g.statement(`} else {`)
		g.reportAllocation("appending to struct slice "+targetRef, `len(`+targetRef+`) == cap(`+targetRef+`)`, 1)
		g.statementIndent(fmt.Sprintf(`%s = append(%s, %s)`, targetRef, targetRef, value.name))
		g.statement(`}`)
	default:
		panic(state.capture.field.Type.String())
	}
}

func (g *codeGenerator) reportAllocation(cause string, condition string, indent int) {
	if !g.printAllocations {
		return
	}
	if condition == "" {
		g.statementCustomIndent(fmt.Sprintf(`println("allocation: %d: %s")`, g.lines, cause), indent)
		return
	}
	g.statementCustomIndent(`if `+condition+` {`, indent)
	g.statementCustomIndent(fmt.Sprintf(`println("allocation: %d: %s")`, g.lines, cause), indent+1)
	g.statementCustomIndent(`}`, indent)
}

func (g *codeGenerator) getFieldRef(variable generatedVariable, fieldIndex []int) string {
	fieldName := variable.typ.FieldByIndex(fieldIndex).Name
	return variable.name + `.` + fieldName
}

func (g *codeGenerator) handleMismatchIndent(state generatorState, indent int) {
	g.statementIndent(fmt.Sprintf(`p.SetTokenError(%q)`, state.failUnexpectedWith))
	g.gotoLabelIndent(state.errorLabel, indent)
}

func (g *codeGenerator) processToken(state generatorState) {
	if state.capture != nil {
		if state.capture.direct {
			g.captureTokens(state)
		} else {
			operation := ` = current.Value`
			if state.capture.nonEmpty {
				operation = ` += current.Value`
			}
			state.capture.nonEmpty = true
			g.statement(state.capture.sourceRef() + operation)
		}
	}
	g.statement(`_, _ = p.Lex.Next()`) // TODO discuss peeking lexer never returning errors
	g.statement(`current = p.Lex.Current()`)
}

func (g *codeGenerator) statement(code string) {
	g.statementCustomIndent(code, 0)
}

func (g *codeGenerator) statementIndent(code string) {
	g.statementCustomIndent(code, 1)
}

func (g *codeGenerator) statementCustomIndent(code string, indent int) {
	if g.out.Len() > 10_000_000 {
		panic(fmt.Errorf("generator sanity check: %d", g.out.Len()))
	}
	// Don't write indentation if it's an empty line for improving readability
	if code != `` {
		g.out.WriteString(strings.Repeat("\t", g.indent+indent))
		g.out.WriteString(code)
	}
	g.out.WriteRune('\n')
	g.lines++
}

func (g *codeGenerator) newLabel(location string, action string) *jumpLabel {
	return &jumpLabel{name: fmt.Sprintf("%s%d%s", location, g.lines, action)}
}

func (g *codeGenerator) gotoLabelIndent(label *jumpLabel, indent int) {
	if label == nil {
		return // Means no goto is necessary
	}
	label.used = true
	g.statementCustomIndent(`goto `+label.name, indent)
}

func (g *codeGenerator) writeLabel(label *jumpLabel) bool {
	if !label.used {
		return false
	}
	g.statementCustomIndent(label.name+`:`, -1)
	return true
}

type generatorState struct {
	target             generatedVariable
	capture            *generatedCapture
	errorLabel         *jumpLabel
	failUnexpectedWith string
}

func (s generatorState) targetRef() string {
	return s.target.name + `.` + s.capture.field.Name
}

type generatedVariable struct {
	name         string
	rValuePrefix string
	typ          reflect.Type
}

type jumpLabel struct {
	name string
	used bool
}

type generatedCapture struct {
	field    reflect.StructField
	direct   bool
	nonEmpty bool
}

func (c *generatedCapture) sourceRef() string {
	if c.direct {
		return `current.Value`
	}
	return `buf` + c.field.Name
}

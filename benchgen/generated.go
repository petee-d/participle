// Code generated by participle parser generator. DO NOT EDIT.
// source: github.com/alecthomas/participle/v2/benchgen.AST

package benchgen

import (
	"strconv"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

func ParseAST(lex *lexer.PeekingLexer, out *AST, allowTrailing bool) error {
	*out = AST{}
	var p generatedASTParser
	p.Lex = lex
	p.Lookahead = 1
	p.parseAST(out)
	if !p.HasErr() && !(lex.Current().EOF() || allowTrailing) {
		p.RestoreOptionalError()
		p.SetTokenError("")
	}
	return p.AsError()
}

type generatedASTParser struct {
	participle.GeneratedParserContext
}

func (p *generatedASTParser) parseAST(out *AST) {
	current := p.Lex.Current()
	p.SetNoError(false)

	// group Entry*
	for matches := 0; ; matches++ {
		branchCheckpoint := p.Lex.MakeCheckpoint()

		// capture Entries from Entry
		// strct Entry
		{
			var vEntry Entry

			// sequence <ident> "=" Value
			// capture Key from <ident>
			// reference <ident>
			if current.Type != -2 {
				p.SetTokenError("")
				goto group34Error
			}
			if vEntry.Key == "" {
				vEntry.Key = current.Value
			} else {
				vEntry.Key += current.Value
			}
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			// literal "="
			if !(current.Value == "=") {
				p.SetTokenError("\"=\" Value")
				goto group34Error
			}
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			// capture Value from Value
			// strct Value
			{
				var vValue Value

				// disjunction <string> | <int>
				{
					branchCheckpoint := p.Lex.MakeCheckpoint()
					var _ = vValue

					// capture String from <string>
					// reference <string>
					if current.Type != -6 {
						p.SetTokenError("")
						goto disjunction71Alt0Error
					}
					if vValue.String == "" {
						vValue.String = current.Value
					} else {
						vValue.String += current.Value
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					goto disjunction71Success
				disjunction71Alt0Error:
					if p.AboveLookahead(branchCheckpoint) {
						goto group34Error
					}
					p.Lex.LoadCheckpoint(branchCheckpoint)
					current = p.Lex.Current()

					// capture Number from <int>
					// reference <int>
					if current.Type != -3 {
						p.SetTokenError("")
						goto disjunction71Alt1Error
					}
					if numValue, err := strconv.ParseInt(current.Value, 0, 64); err != nil {
						p.SetParseError(err.Error())
						goto disjunction71Alt1Error
					} else {
						vValue.Number = int(numValue)
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					goto disjunction71Success
				disjunction71Alt1Error:
					if p.AboveLookahead(branchCheckpoint) {
						goto group34Error
					}
					goto group34Error
				}
			disjunction71Success:
				p.SetNoError(false)

				{
					vValueHeap := vValue
					vEntry.Value = &vValueHeap
				}
			}

			if out.Entries == nil {
				out.Entries = make([]Entry, 1, 2)
				out.Entries[0] = vEntry
			} else {
				out.Entries = append(out.Entries, vEntry)
			}
		}

		if matches >= participle.MaxIterations {
			panic(participle.NewError(current.Pos, "too many iterations of Entry* (> 1000000)"))
		}
		continue
	group34Error:
		p.Lex.LoadCheckpoint(branchCheckpoint)
		current = p.Lex.Current()
		if p.AboveLookahead(branchCheckpoint) {
			goto strctAST28Error
		}
		p.SetNoError(true)
		break
	}

strctAST28Error:
}

// Code generated by Participle. DO NOT EDIT.

package benchgen

import (
	"strconv"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

func (p *AST) ParseOld(lex *lexer.PeekingLexer) error {
	tokens, err := parse0(lex, p)
	if err != nil {
		return err
	}
	if tokens == nil {
		tok, _ := lex.Peek(0)
		if tok.EOF() {
			return nil
		}
		return participle.UnexpectedTokenError{Unexpected: tok, Expect: ""}
	}
	return nil
}

// AST = Entry* . (strct)
func parse0(lex *lexer.PeekingLexer, owner *AST) ([]string, error) {
	tokens, err := parse1(lex, owner)
	if err != nil || tokens == nil {
		return nil, err
	}
	return tokens, nil
}

// Entry* (group)
func parse1(lex *lexer.PeekingLexer, owner *AST) ([]string, error) {
	var (
		matches int
		tokens  []string
	)
	for {
		sub, err := parse2(lex, owner)
		if err != nil {
			return nil, err
		} else if sub == nil {
			break
		}
		tokens = append(tokens, sub...)
		matches++
	}
	if matches >= 1000000 {
		return nil, nil
	}
	return tokens, nil
}

// Entry (capture)
func parse2(lex *lexer.PeekingLexer, owner *AST) ([]string, error) {
	el := Entry{}
	tokens, err := parse3(lex, &el)
	if err != nil || tokens == nil {
		return nil, err
	}
	owner.Entries = append(owner.Entries, el)
	return []string{}, nil
}

// Entry = <ident> "=" Value . (strct)
func parse3(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
	tokens, err := parse4(lex, owner)
	if err != nil || tokens == nil {
		return nil, err
	}
	return tokens, nil
}

// <ident> "=" Value (sequence)
func parse4(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
	var all []string
	// <ident>
	if tokens, err := parse5(lex, owner); err != nil || tokens == nil {
		return nil, err
	} else {
		all = append(all, tokens...)
	}
	// "="
	if tokens, err := parse7(lex, owner); err != nil {
		return nil, err
	} else if tokens == nil {
		tok, _ := lex.Peek(0)
		return nil, participle.UnexpectedTokenError{Unexpected: tok, Expect: "\"=\""}
	} else {
		all = append(all, tokens...)
	}
	// Value
	if tokens, err := parse8(lex, owner); err != nil {
		return nil, err
	} else if tokens == nil {
		tok, _ := lex.Peek(0)
		return nil, participle.UnexpectedTokenError{Unexpected: tok, Expect: "Value"}
	} else {
		all = append(all, tokens...)
	}
	return all, nil
}

// <ident> (capture)
func parse5(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
	tokens, err := parse6(lex, owner)
	if err != nil || tokens == nil {
		return nil, err
	}
	for _, tok := range tokens {
		owner.Key += tok
	}
	return []string{}, nil
}

// <ident> (reference)
func parse6(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
	tok, err := lex.Peek(0)
	if err != nil || tok.Type != -2 {
		return nil, err
	}
	_, _ = lex.Next()
	return []string{tok.Value}, nil
}

// "=" (literal)
func parse7(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
	tok, err := lex.Peek(0)
	if err != nil || tok.Value != "=" {
		return nil, err
	}
	_, _ = lex.Next()
	return []string{tok.Value}, nil
}

// Value (capture)
func parse8(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
	el := new(Value)
	tokens, err := parse9(lex, el)
	if err != nil || tokens == nil {
		return nil, err
	}
	owner.Value = el
	return []string{}, nil
}

// Value = <string> | <int> . (strct)
func parse9(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
	tokens, err := parse10(lex, owner)
	if err != nil || tokens == nil {
		return nil, err
	}
	return tokens, nil
}

// <string> | <int> (disjunction)
func parse10(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
	var (
		candidate = lex.Clone()
		lastErr   error
	)
	// <string>
	if tokens, err := parse11(candidate, owner); err != nil || tokens == nil {
		lastErr = err
		*candidate = *lex
	} else if tokens != nil {
		*lex = *candidate
		return tokens, nil
	}
	// <int>
	if tokens, err := parse13(candidate, owner); err != nil || tokens == nil {
		lastErr = err
		*candidate = *lex
	} else if tokens != nil {
		*lex = *candidate
		return tokens, nil
	}
	*lex = *candidate
	return nil, lastErr
}

// <string> (capture)
func parse11(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
	tokens, err := parse12(lex, owner)
	if err != nil || tokens == nil {
		return nil, err
	}
	for _, tok := range tokens {
		owner.String += tok
	}
	return []string{}, nil
}

// <string> (reference)
func parse12(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
	tok, err := lex.Peek(0)
	if err != nil || tok.Type != -6 {
		return nil, err
	}
	_, _ = lex.Next()
	return []string{tok.Value}, nil
}

// <int> (capture)
func parse13(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
	tokens, err := parse14(lex, owner)
	if err != nil || tokens == nil {
		return nil, err
	}
	for _, tok := range tokens {
		if n, err := strconv.ParseInt(tok, 10, 64); err != nil {
			owner.Number++
		} else {
			owner.Number = int(n)
		}
	}
	return []string{}, nil
}

// <int> (reference)
func parse14(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
	tok, err := lex.Peek(0)
	if err != nil || tok.Type != -3 {
		return nil, err
	}
	_, _ = lex.Next()
	return []string{tok.Value}, nil
}

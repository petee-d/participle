// Code generated by participle parser generator. DO NOT EDIT.
// source: github.com/alecthomas/participle/v2.Stuff

package generated

import (
	"strconv"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"

	source "github.com/alecthomas/participle/v2"
)

func ParseStuff(lex *lexer.PeekingLexer, out *source.Stuff, allowTrailing bool) error {
	*out = source.Stuff{}
	var p generatedStuffParser
	p.Lex = lex
	p.Lookahead = 2
	p.parseStuff(out)
	if !p.HasErr() && !(lex.Current().EOF() || allowTrailing) {
		p.RestoreOptionalError()
		p.SetTokenError("")
	}
	return p.AsError()
}

type generatedStuffParser struct {
	participle.GeneratedParserContext
}

func (p *generatedStuffParser) parseStuff(out *source.Stuff) {
	current := p.Lex.Current()
	p.SetNoError(false)
	out.Pos = current.Pos

	// sequence "test" (((?! "str" "ing") <ident>) | (<ident> <ident>)) SubStuff+ ("x"? "y"? "z"?)! ("." ".")? "."? ("4" "2"?) (<ident> <ident>)
	// literal "test"
	if !(current.Value == "test") {
		p.SetTokenError("")
		goto strctStuff30Error
	}
	_, _ = p.Lex.Next()
	current = p.Lex.Current()

	// disjunction ((?! "str" "ing") <ident>) | (<ident> <ident>)
	{
		branchCheckpoint := p.Lex.MakeCheckpoint()
		var _ = *out

		// sequence (?! "str" "ing") <ident>
		// lookaheadGroup (?! "str" "ing")
		{
			branchCheckpoint := p.Lex.MakeCheckpoint()

			// sequence "str" "ing"
			// literal "str"
			if !(current.Value == "str") {
				p.SetTokenError("")
				goto lookahead55Error
			}
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			// literal "ing"
			if !(current.Value == "ing") {
				p.SetTokenError("\"ing\"")
				goto lookahead55Error
			}
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			p.Lex.LoadCheckpoint(branchCheckpoint)
			current = p.Lex.Current()
			p.SetTokenError("")
			goto disjunction46Alt0Error
		lookahead55Error:
			p.Lex.LoadCheckpoint(branchCheckpoint)
			current = p.Lex.Current()
			p.SetNoError(false)
		}

		// capture A from <ident>
		// reference <ident>
		if current.Type != -2 {
			p.SetTokenError("<ident>")
			goto disjunction46Alt0Error
		}
		if out.A == "" {
			out.A = current.Value
		} else {
			out.A += current.Value
		}
		_, _ = p.Lex.Next()
		current = p.Lex.Current()

		goto disjunction46Success
	disjunction46Alt0Error:
		if p.AboveLookahead(branchCheckpoint) {
			goto strctStuff30Error
		}
		p.Lex.LoadCheckpoint(branchCheckpoint)
		current = p.Lex.Current()

		// sequence <ident> <ident>
		// capture A from <ident>
		// reference <ident>
		if current.Type != -2 {
			p.SetTokenError("")
			goto disjunction46Alt1Error
		}
		if out.A == "" {
			out.A = current.Value
		} else {
			out.A += current.Value
		}
		_, _ = p.Lex.Next()
		current = p.Lex.Current()

		// capture A from <ident>
		// reference <ident>
		if current.Type != -2 {
			p.SetTokenError("<ident>")
			goto disjunction46Alt1Error
		}
		if out.A == "" {
			out.A = current.Value
		} else {
			out.A += current.Value
		}
		_, _ = p.Lex.Next()
		current = p.Lex.Current()

		goto disjunction46Success
	disjunction46Alt1Error:
		if p.AboveLookahead(branchCheckpoint) {
			goto strctStuff30Error
		}
		goto strctStuff30Error
	}
disjunction46Success:
	p.SetNoError(false)

	// group SubStuff+
	for matches := 0; ; matches++ {
		branchCheckpoint := p.Lex.MakeCheckpoint()

		// capture Sub from SubStuff
		// strct SubStuff
		{
			var vSubStuff source.SubStuff

			// disjunction ("!" IntStuff) | ("!"? StringStuff)
			{
				branchCheckpoint := p.Lex.MakeCheckpoint()
				var _ = vSubStuff

				// sequence "!" IntStuff
				// capture IntPrefix from "!"
				// literal "!"
				if !(current.Value == "!") {
					p.SetTokenError("")
					goto disjunction153Alt0Error
				}
				if vSubStuff.IntPrefix == "" {
					vSubStuff.IntPrefix = current.Value
				} else {
					vSubStuff.IntPrefix += current.Value
				}
				_, _ = p.Lex.Next()
				current = p.Lex.Current()

				// capture Int from IntStuff
				// strct IntStuff
				{
					var vIntStuff source.IntStuff

					// sequence "(" <int> ("+" | "-") <int> ")"
					// literal "("
					if !(current.Value == "(") {
						p.SetTokenError("IntStuff")
						goto disjunction153Alt0Error
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					// capture A from <int>
					// reference <int>
					if current.Type != -3 {
						p.SetTokenError("<int> (\"+\" | \"-\") <int> \")\"")
						goto disjunction153Alt0Error
					}
					if numValue, err := strconv.ParseInt(current.Value, 0, 32); err != nil {
						p.SetParseError(err.Error())
						goto disjunction153Alt0Error
					} else {
						vIntStuff.A = int32(numValue)
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					// capture Op from ("+" | "-")
					// disjunction "+" | "-"
					switch current.Value {
					case "+", "-":
						if vIntStuff.Op == "" {
							vIntStuff.Op = current.Value
						} else {
							vIntStuff.Op += current.Value
						}
						_, _ = p.Lex.Next()
						current = p.Lex.Current()
					default:
						p.SetTokenError("(\"+\" | \"-\") <int> \")\"")
						goto disjunction153Alt0Error
					}

					// capture B from <int>
					// reference <int>
					if current.Type != -3 {
						p.SetTokenError("<int> \")\"")
						goto disjunction153Alt0Error
					}
					if numValue, err := strconv.ParseFloat(current.Value, 64); err != nil {
						p.SetParseError(err.Error())
						goto disjunction153Alt0Error
					} else {
						vIntStuff.B = numValue
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					// literal ")"
					if !(current.Value == ")") {
						p.SetTokenError("\")\"")
						goto disjunction153Alt0Error
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					{
						vIntStuffHeap := vIntStuff
						vSubStuff.Int = &vIntStuffHeap
					}
				}

				goto disjunction153Success
			disjunction153Alt0Error:
				if p.AboveLookahead(branchCheckpoint) {
					goto group144Error
				}
				p.Lex.LoadCheckpoint(branchCheckpoint)
				current = p.Lex.Current()

				// sequence "!"? StringStuff
				// group "!"?
				for {
					branchCheckpoint := p.Lex.MakeCheckpoint()

					// literal "!"
					if !(current.Value == "!") {
						p.SetTokenError("")
						goto group256Error
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					break
				group256Error:
					p.Lex.LoadCheckpoint(branchCheckpoint)
					current = p.Lex.Current()
					if p.AboveLookahead(branchCheckpoint) {
						goto disjunction153Alt1Error
					}
					p.SetNoError(true)
					break
				}

				// capture Str from StringStuff
				// strct StringStuff
				{
					var vStringStuff source.StringStuff
					rawStart := p.Lex.RawCursor()

					// sequence "(" <ident> "is" <ident> ")"
					// literal "("
					if !(current.Value == "(") {
						p.SetTokenError("StringStuff")
						goto disjunction153Alt1Error
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					// capture Object from <ident>
					// reference <ident>
					if current.Type != -2 {
						p.SetTokenError("<ident> \"is\" <ident> \")\"")
						goto disjunction153Alt1Error
					}
					if vStringStuff.Object == "" {
						vStringStuff.Object = current.Value
					} else {
						vStringStuff.Object += current.Value
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					// literal "is"
					if !(current.Value == "is") {
						p.SetTokenError("\"is\" <ident> \")\"")
						goto disjunction153Alt1Error
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					// capture Adjective from <ident>
					// reference <ident>
					if current.Type != -2 {
						p.SetTokenError("<ident> \")\"")
						goto disjunction153Alt1Error
					}
					if vStringStuff.Adjective == "" {
						vStringStuff.Adjective = current.Value
					} else {
						vStringStuff.Adjective += current.Value
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					// literal ")"
					if !(current.Value == ")") {
						p.SetTokenError("\")\"")
						goto disjunction153Alt1Error
					}
					_, _ = p.Lex.Next()
					current = p.Lex.Current()

					vStringStuff.Tokens = p.Lex.Range(rawStart, p.Lex.RawCursor())
					{
						vStringStuffHeap := vStringStuff
						vSubStuff.Str = &vStringStuffHeap
					}
				}

				goto disjunction153Success
			disjunction153Alt1Error:
				if p.AboveLookahead(branchCheckpoint) {
					goto group144Error
				}
				goto group144Error
			}
		disjunction153Success:
			p.SetNoError(false)

			if out.Sub == nil {
				out.Sub = make([]source.SubStuff, 1, 2)
				out.Sub[0] = vSubStuff
			} else {
				out.Sub = append(out.Sub, vSubStuff)
			}
		}

		if matches >= participle.MaxIterations {
			panic(participle.NewError(current.Pos, "too many iterations of SubStuff+ (> 1000000)"))
		}
		continue
	group144Error:
		p.Lex.LoadCheckpoint(branchCheckpoint)
		current = p.Lex.Current()
		if p.AboveLookahead(branchCheckpoint) {
			goto strctStuff30Error
		}
		if matches == 0 {
			p.SetParseError("sub-expression SubStuff+ must match at least once")
			goto strctStuff30Error
		}
		p.SetNoError(true)
		break
	}

	// group ("x"? "y"? "z"?)!
	{
		nonEmptyCheckpoint := p.Lex.MakeCheckpoint()
		// sequence "x"? "y"? "z"?
		// group "x"?
		for {
			branchCheckpoint := p.Lex.MakeCheckpoint()

			// capture B from "x"
			// literal "x"
			if !(current.Value == "x") {
				p.SetTokenError("")
				goto group385Error
			}
			{
				var ptrValue string
				if out.B != nil {
					ptrValue = *out.B
				}
				if ptrValue == "" {
					ptrValue = current.Value
				} else {
					ptrValue += current.Value
				}
				out.B = &ptrValue
			}
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			break
		group385Error:
			p.Lex.LoadCheckpoint(branchCheckpoint)
			current = p.Lex.Current()
			if p.AboveLookahead(branchCheckpoint) {
				goto strctStuff30Error
			}
			p.SetNoError(true)
			break
		}

		// group "y"?
		for {
			branchCheckpoint := p.Lex.MakeCheckpoint()

			// capture B from "y"
			// literal "y"
			if !(current.Value == "y") {
				p.SetTokenError("")
				goto group421Error
			}
			{
				var ptrValue string
				if out.B != nil {
					ptrValue = *out.B
				}
				if ptrValue == "" {
					ptrValue = current.Value
				} else {
					ptrValue += current.Value
				}
				out.B = &ptrValue
			}
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			break
		group421Error:
			p.Lex.LoadCheckpoint(branchCheckpoint)
			current = p.Lex.Current()
			if p.AboveLookahead(branchCheckpoint) {
				goto strctStuff30Error
			}
			p.SetNoError(true)
			break
		}

		// group "z"?
		for {
			branchCheckpoint := p.Lex.MakeCheckpoint()

			// capture B from "z"
			// literal "z"
			if !(current.Value == "z") {
				p.SetTokenError("")
				goto group457Error
			}
			{
				var ptrValue string
				if out.B != nil {
					ptrValue = *out.B
				}
				if ptrValue == "" {
					ptrValue = current.Value
				} else {
					ptrValue += current.Value
				}
				out.B = &ptrValue
			}
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			break
		group457Error:
			p.Lex.LoadCheckpoint(branchCheckpoint)
			current = p.Lex.Current()
			if p.AboveLookahead(branchCheckpoint) {
				goto strctStuff30Error
			}
			p.SetNoError(true)
			break
		}

		if p.Lex.Cursor() == nonEmptyCheckpoint.Cursor() {
			p.SetParseError("sub-expression (\"x\"? \"y\"? \"z\"?)! cannot be empty")
			goto strctStuff30Error
		}
	}
	// group ("." ".")?
	for {
		branchCheckpoint := p.Lex.MakeCheckpoint()

		// capture C from ("." ".")
		// sequence "." "."
		// literal "."
		if !(current.Value == ".") {
			p.SetTokenError("")
			goto group498Error
		}
		out.C = true
		_, _ = p.Lex.Next()
		current = p.Lex.Current()

		// literal "."
		if !(current.Value == ".") {
			p.SetTokenError("\".\"")
			goto group498Error
		}
		out.C = true
		_, _ = p.Lex.Next()
		current = p.Lex.Current()

		break
	group498Error:
		p.Lex.LoadCheckpoint(branchCheckpoint)
		current = p.Lex.Current()
		if p.AboveLookahead(branchCheckpoint) {
			goto strctStuff30Error
		}
		p.SetNoError(true)
		break
	}

	// group "."?
	for {
		branchCheckpoint := p.Lex.MakeCheckpoint()

		// literal "."
		if !(current.Value == ".") {
			p.SetTokenError("")
			goto group533Error
		}
		_, _ = p.Lex.Next()
		current = p.Lex.Current()

		break
	group533Error:
		p.Lex.LoadCheckpoint(branchCheckpoint)
		current = p.Lex.Current()
		if p.AboveLookahead(branchCheckpoint) {
			goto strctStuff30Error
		}
		p.SetNoError(true)
		break
	}

	// capture D from ("4" "2"?)
	{
		var bufD string
		// sequence "4" "2"?
		// literal "4"
		if !(current.Value == "4") {
			p.SetTokenError("(\"4\" \"2\"?) (<ident> <ident>)")
			goto strctStuff30Error
		}
		bufD = current.Value
		_, _ = p.Lex.Next()
		current = p.Lex.Current()

		// group "2"?
		for {
			branchCheckpoint := p.Lex.MakeCheckpoint()

			// literal "2"
			if !(current.Value == "2") {
				p.SetTokenError("")
				goto group569Error
			}
			bufD += current.Value
			_, _ = p.Lex.Next()
			current = p.Lex.Current()

			break
		group569Error:
			p.Lex.LoadCheckpoint(branchCheckpoint)
			current = p.Lex.Current()
			if p.AboveLookahead(branchCheckpoint) {
				goto strctStuff30Error
			}
			p.SetNoError(true)
			break
		}

		{
			var ptrValue int
			if out.D != nil {
				ptrValue = *out.D
			}
			if numValue, err := strconv.ParseInt(bufD, 0, 64); err != nil {
				p.SetParseError(err.Error())
				goto strctStuff30Error
			} else {
				ptrValue = int(numValue)
			}
			out.D = &ptrValue
		}
	}

	// capture E from (<ident> <ident>)
	// sequence <ident> <ident>
	// reference <ident>
	if current.Type != -2 {
		p.SetTokenError("(<ident> <ident>)")
		goto strctStuff30Error
	}
	{
		if out.E == nil {
			out.E = make([]string, 0, 2)
		}
		var sliceItem string
		if sliceItem == "" {
			sliceItem = current.Value
		} else {
			sliceItem += current.Value
		}
		out.E = append(out.E, sliceItem)
	}
	_, _ = p.Lex.Next()
	current = p.Lex.Current()

	// reference <ident>
	if current.Type != -2 {
		p.SetTokenError("<ident>")
		goto strctStuff30Error
	}
	{
		if out.E == nil {
			out.E = make([]string, 0, 2)
		}
		var sliceItem string
		if sliceItem == "" {
			sliceItem = current.Value
		} else {
			sliceItem += current.Value
		}
		out.E = append(out.E, sliceItem)
	}
	_, _ = p.Lex.Next()
	current = p.Lex.Current()

	out.EndPos = current.Pos
strctStuff30Error:
}
